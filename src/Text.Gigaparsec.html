<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Trustworthy #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-3"></span><span class="annot"><span class="hs-comment">{-|
Module      : Text.Gigaparsec
Description : Contains the bulk of the core combinators.
License     : BSD-3-Clause
Maintainer  : Jamie Willis, Gigaparsec Maintainers
Stability   : stable

This object contains the core combinators and parser type: all parsers will require something from
within!

TODO: what is inside it?

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-17"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Text.Gigaparsec</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-18"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier">Parsec</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#Result"><span class="hs-identifier">Result</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#parse"><span class="hs-identifier">parse</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-19"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Primitive Combinators</span></span><span>
</span><span id="line-20"></span><span>  </span><span class="hs-comment">-- | These combinators are specific to parser combinators. In one way or another, they influence</span><span>
</span><span id="line-21"></span><span>  </span><span class="hs-comment">-- how a parser consumes input, or under what conditions a parser does or does not fail. These are</span><span>
</span><span id="line-22"></span><span>  </span><span class="hs-comment">-- really important for most practical parsing considerations, although lookAhead is much less</span><span>
</span><span id="line-23"></span><span>  </span><span class="hs-comment">-- well used.</span><span>
</span><span id="line-24"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.html#atomic"><span class="hs-identifier">atomic</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#lookAhead"><span class="hs-identifier">lookAhead</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#notFollowedBy"><span class="hs-identifier">notFollowedBy</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Consumptionless Parsers</span></span><span>
</span><span id="line-26"></span><span>  </span><span class="hs-comment">-- | These combinators and parsers do not consume input: they are the most primitive ways of</span><span>
</span><span id="line-27"></span><span>  </span><span class="hs-comment">-- producing successes and failures with the minimal possible effect on the parse. They are,</span><span>
</span><span id="line-28"></span><span>  </span><span class="hs-comment">-- however, reasonably useful; in particular, `pure` and `unit` can be put to good use in</span><span>
</span><span id="line-29"></span><span>  </span><span class="hs-comment">-- injecting results into a parser without needing to consume anything, or mapping another parser.</span><span>
</span><span id="line-30"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword">unit</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>  </span><span class="annot"><span class="hs-comment">-- *** Re-exported from &quot;Control.Applicative&quot;</span></span><span>
</span><span id="line-32"></span><span>    </span><span class="annot"><span class="hs-identifier">pure</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">empty</span></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Result Changing Combinators</span></span><span>
</span><span id="line-34"></span><span>  </span><span class="hs-comment">-- | These combinators change the result of the parser they are called on into a value of a</span><span>
</span><span id="line-35"></span><span>  </span><span class="hs-comment">-- different type. This new result value may or may not be derived from the previous result.</span><span>
</span><span id="line-36"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator">($&gt;)</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-37"></span><span>  </span><span class="annot"><span class="hs-comment">-- *** Re-exported from &quot;Data.Functor&quot;</span></span><span>
</span><span id="line-38"></span><span>    </span><span class="annot"><span class="hs-operator">(&lt;$&gt;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(&lt;$)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">void</span></span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Sequencing Combinators</span></span><span>
</span><span id="line-40"></span><span>  </span><span class="hs-comment">-- | These combinators all combine two parsers in sequence. The first argument of the combinator</span><span>
</span><span id="line-41"></span><span>  </span><span class="hs-comment">-- will be executed first, then the second argument second. The results of both parsers are</span><span>
</span><span id="line-42"></span><span>  </span><span class="hs-comment">-- combined in some way (depending on the individual combinator). If one of the parsers fails, the</span><span>
</span><span id="line-43"></span><span>  </span><span class="hs-comment">-- combinator as a whole fails.</span><span>
</span><span id="line-44"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.html#%3C~%3E"><span class="hs-operator">(&lt;~&gt;)</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-45"></span><span>  </span><span class="annot"><span class="hs-comment">-- *** Re-exported from &quot;Control.Applicative&quot;</span></span><span>
</span><span id="line-46"></span><span>    </span><span class="annot"><span class="hs-operator">(&lt;*&gt;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">liftA2</span></span><span class="hs-special">,</span><span>
</span><span id="line-47"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Branching Combinators</span></span><span>
</span><span id="line-48"></span><span>  </span><span class="hs-comment">-- | These combinators allow for parsing one alternative or another. All of these combinators are</span><span>
</span><span id="line-49"></span><span>  </span><span class="hs-comment">-- /left-biased/, which means that the left-hand side of the combinator is tried first: the</span><span>
</span><span id="line-50"></span><span>  </span><span class="hs-comment">-- right-hand side of the combinator will only be tried when the left-hand one failed (and did not</span><span>
</span><span id="line-51"></span><span>  </span><span class="hs-comment">-- consume input in the process).</span><span>
</span><span id="line-52"></span><span>
</span><span id="line-53"></span><span>  </span><span class="annot"><span class="hs-comment">-- *** Re-exported from &quot;Control.Applicative&quot;</span></span><span>
</span><span id="line-54"></span><span>    </span><span class="annot"><span class="hs-operator">(&lt;|&gt;)</span></span><span class="hs-special">,</span><span>
</span><span id="line-55"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Selective Combinators</span></span><span>
</span><span id="line-56"></span><span>  </span><span class="hs-comment">-- | These combinators will decide which branch to take next based on the result of another parser.</span><span>
</span><span id="line-57"></span><span>  </span><span class="hs-comment">-- This differs from combinators like `(&lt;|&gt;)` which make decisions based on the success/failure of</span><span>
</span><span id="line-58"></span><span>  </span><span class="hs-comment">-- a parser: here the result of a /successful/ parse will direct which option is done.</span><span>
</span><span id="line-59"></span><span>
</span><span id="line-60"></span><span>  </span><span class="annot"><span class="hs-comment">-- *** Re-exported from &quot;Control.Selective&quot;</span></span><span>
</span><span id="line-61"></span><span>    </span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.2/selective-0.7-f512198613fde586129ddb75ddbbf8b631605bdaf9ca135692110d9a6ec21db9/share/doc/html/src/Control.Selective.html#select"><span class="hs-identifier">select</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.2/selective-0.7-f512198613fde586129ddb75ddbbf8b631605bdaf9ca135692110d9a6ec21db9/share/doc/html/src/Control.Selective.html#branch"><span class="hs-identifier">branch</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Filtering Combinators</span></span><span>
</span><span id="line-64"></span><span>  </span><span class="hs-comment">-- | These combinators perform filtering on the results of a parser. This means that, given the</span><span>
</span><span id="line-65"></span><span>  </span><span class="hs-comment">-- result of a parser, they will perform some function on that result, and the success of that</span><span>
</span><span id="line-66"></span><span>  </span><span class="hs-comment">-- function effects whether or not the parser fails.</span><span>
</span><span id="line-67"></span><span>
</span><span id="line-68"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Folding Combinators</span></span><span>
</span><span id="line-69"></span><span>  </span><span class="hs-comment">-- | These combinators repeatedly execute a parser (at least zero or one times depending on the</span><span>
</span><span id="line-70"></span><span>  </span><span class="hs-comment">-- specific combinator) until it fails. The results of the successes are then combined together</span><span>
</span><span id="line-71"></span><span>  </span><span class="hs-comment">-- using a folding function. An initial value for the accumulation may be given (for the folds),</span><span>
</span><span id="line-72"></span><span>  </span><span class="hs-comment">-- or the first successful result is the initial accumulator (for the reduces). These are</span><span>
</span><span id="line-73"></span><span>  </span><span class="hs-comment">-- implemented efficiently and do not need to construct any intermediate list with which to store</span><span>
</span><span id="line-74"></span><span>  </span><span class="hs-comment">-- the results.</span><span>
</span><span id="line-75"></span><span>    </span><span class="annot"><span class="hs-identifier">many</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">some</span></span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- TODO: these need to be properly categorised</span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span class="hs-comment">-- NOTE:</span><span>
</span><span id="line-79"></span><span class="hs-comment">-- This module is mostly just for re-exports, though there may be primitive</span><span>
</span><span id="line-80"></span><span class="hs-comment">-- combinators in here too. If user can see it, it can go in here.</span><span>
</span><span id="line-81"></span><span class="hs-comment">--</span><span>
</span><span id="line-82"></span><span class="hs-comment">-- Care MUST be taken to not expose /any/ implementation details from</span><span>
</span><span id="line-83"></span><span class="hs-comment">-- `Internal`: when they are in the public API, we are locked into them!</span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html"><span class="hs-identifier">Text.Gigaparsec.Internal</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier">Parsec</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#unParsec"><span class="hs-identifier">unParsec</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#emptyState"><span class="hs-identifier">emptyState</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Functor</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">void</span></span><span class="hs-special">)</span><span>
</span><span id="line-88"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">liftA2</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(&lt;|&gt;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">empty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">many</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">some</span></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- liftA2 required until 9.6</span><span>
</span><span id="line-89"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.2/selective-0.7-f512198613fde586129ddb75ddbbf8b631605bdaf9ca135692110d9a6ec21db9/share/doc/html/src/Control.Selective.html"><span class="hs-identifier">Control.Selective</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.2/selective-0.7-f512198613fde586129ddb75ddbbf8b631605bdaf9ca135692110d9a6ec21db9/share/doc/html/src/Control.Selective.html#select"><span class="hs-identifier">select</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="file:///home/runner/.cabal/store/ghc-9.6.2/selective-0.7-f512198613fde586129ddb75ddbbf8b631605bdaf9ca135692110d9a6ec21db9/share/doc/html/src/Control.Selective.html#branch"><span class="hs-identifier">branch</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span class="hs-comment">-- Hiding the Internal module seems like the better bet: nobody needs to see it anyway :)</span><span>
</span><span id="line-92"></span><span class="hs-comment">-- re-expose like this to prevent hlint suggesting import refinement into internal</span><span>
</span><span id="line-93"></span><span class="hs-comment">--type Parsec :: * -&gt; *</span><span>
</span><span id="line-94"></span><span class="hs-comment">--type Parsec = Internal.Parsec</span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#Result"><span class="hs-identifier hs-type">Result</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span>
</span><span id="line-97"></span><span class="hs-keyword">data</span><span> </span><span id="Result"><span class="annot"><a href="Text.Gigaparsec.html#Result"><span class="hs-identifier hs-var">Result</span></a></span></span><span> </span><span id="local-6989586621679049906"><span class="annot"><a href="#local-6989586621679049906"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Success"><span class="annot"><a href="Text.Gigaparsec.html#Success"><span class="hs-identifier hs-var">Success</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679049906"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="Failure"><span class="annot"><a href="Text.Gigaparsec.html#Failure"><span class="hs-identifier hs-var">Failure</span></a></span></span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="annot"><span class="hs-keyword">stock</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679049965"><span id="local-6989586621679049970"><span id="local-6989586621679049974"><span class="annot"><span class="annottext">Int -&gt; Result a -&gt; ShowS
[Result a] -&gt; ShowS
Result a -&gt; String
(Int -&gt; Result a -&gt; ShowS)
-&gt; (Result a -&gt; String) -&gt; ([Result a] -&gt; ShowS) -&gt; Show (Result a)
forall a. Show a =&gt; Int -&gt; Result a -&gt; ShowS
forall a. Show a =&gt; [Result a] -&gt; ShowS
forall a. Show a =&gt; Result a -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: forall a. Show a =&gt; Int -&gt; Result a -&gt; ShowS
showsPrec :: Int -&gt; Result a -&gt; ShowS
$cshow :: forall a. Show a =&gt; Result a -&gt; String
show :: Result a -&gt; String
$cshowList :: forall a. Show a =&gt; [Result a] -&gt; ShowS
showList :: [Result a] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679049979"><span id="local-6989586621679049982"><span class="annot"><span class="annottext">Result a -&gt; Result a -&gt; Bool
(Result a -&gt; Result a -&gt; Bool)
-&gt; (Result a -&gt; Result a -&gt; Bool) -&gt; Eq (Result a)
forall a. Eq a =&gt; Result a -&gt; Result a -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: forall a. Eq a =&gt; Result a -&gt; Result a -&gt; Bool
== :: Result a -&gt; Result a -&gt; Bool
$c/= :: forall a. Eq a =&gt; Result a -&gt; Result a -&gt; Bool
/= :: Result a -&gt; Result a -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-98"></span><span>
</span><span id="line-99"></span><span id="local-6989586621679049896"><span class="annot"><a href="Text.Gigaparsec.html#parse"><span class="hs-identifier hs-type">parse</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679049896"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#Result"><span class="hs-identifier hs-type">Result</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679049896"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-100"></span><span id="parse"><span class="annot"><span class="annottext">parse :: forall a. Parsec a -&gt; String -&gt; Result a
</span><a href="Text.Gigaparsec.html#parse"><span class="hs-identifier hs-var hs-var">parse</span></a></span></span><span> </span><span id="local-6989586621679049986"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679049986"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679049987"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679049987"><span class="hs-identifier hs-var">input</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
-&gt; forall r. State -&gt; (a -&gt; State -&gt; r) -&gt; (State -&gt; r) -&gt; r
forall a.
Parsec a
-&gt; forall r. State -&gt; (a -&gt; State -&gt; r) -&gt; (State -&gt; r) -&gt; r
</span><a href="Text.Gigaparsec.Internal.html#unParsec"><span class="hs-identifier hs-var">unParsec</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679049986"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; State
</span><a href="Text.Gigaparsec.Internal.html#emptyState"><span class="hs-identifier hs-var">emptyState</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679049987"><span class="hs-identifier hs-var">input</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; State -&gt; Result a
forall {a} {p}. a -&gt; p -&gt; Result a
</span><a href="#local-6989586621679049988"><span class="hs-identifier hs-var">good</span></a></span><span> </span><span class="annot"><span class="annottext">State -&gt; Result a
forall {p} {a}. p -&gt; Result a
</span><a href="#local-6989586621679049989"><span class="hs-identifier hs-var">bad</span></a></span><span>
</span><span id="line-101"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679049988"><span class="annot"><span class="annottext">good :: a -&gt; p -&gt; Result a
</span><a href="#local-6989586621679049988"><span class="hs-identifier hs-var hs-var">good</span></a></span></span><span> </span><span id="local-6989586621679049990"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679049990"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="annottext">p
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Result a
forall a. a -&gt; Result a
</span><a href="Text.Gigaparsec.html#Success"><span class="hs-identifier hs-var">Success</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679049990"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-102"></span><span>        </span><span id="local-6989586621679049989"><span class="annot"><span class="annottext">bad :: p -&gt; Result a
</span><a href="#local-6989586621679049989"><span class="hs-identifier hs-var hs-var">bad</span></a></span></span><span> </span><span class="annot"><span class="annottext">p
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Result a
forall a. Result a
</span><a href="Text.Gigaparsec.html#Failure"><span class="hs-identifier hs-var">Failure</span></a></span><span>
</span><span id="line-103"></span><span>
</span><span id="line-104"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses its argument @p@, but rolls back any consumed input on failure.

If the parser @p@ succeeds, then @atomic p@ has no effect. However, if @p@ failed,
then any input that it consumed is rolled back. This has two uses: it ensures that
the parser @p@ is all-or-nothing when consuming input, and it allows for
parsers that consume input to backtrack when they fail (with '(&lt;|&gt;)'). It should be
used for the latter purpose sparingly, however, since excessive backtracking in a
parser can result in much lower efficiency.

&gt;&gt;&gt; parse (string &quot;abc&quot; &lt;|&gt; string &quot;abd&quot;) &quot;abd&quot;
Failure .. -- first parser consumed a, so no backtrack
&gt;&gt;&gt; parse (atomic (string &quot;abc&quot;) &lt;|&gt; string &quot;abd&quot;) &quot;abd&quot;
Success &quot;abd&quot; -- first parser does not consume input on failure now

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-121"></span><span id="local-6989586621679049907"><span class="annot"><a href="Text.Gigaparsec.html#atomic"><span class="hs-identifier hs-type">atomic</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679049907"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parser, @p@, to execute, if it fails, it will not have consumed input.</span></span><span>
</span><span id="line-122"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679049907"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that tries @p@, but never consumes input if it fails.</span></span><span>
</span><span id="line-123"></span><span id="atomic"><span class="annot"><span class="annottext">atomic :: forall a. Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.html#atomic"><span class="hs-identifier hs-var hs-var">atomic</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec a
forall a. HasCallStack =&gt; a
</span><span class="hs-identifier hs-var">undefined</span></span><span> </span><span class="hs-comment">--TODO:</span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span class="annot"><span class="hs-comment">{-| This combinator parses its argument @p@, but does not consume input if it succeeds.

If the parser @p@ succeeds, then @lookAhead p@ will roll back any input consumed
whilst parsing @p@. If @p@ fails, however, then the whole combinator fails and
any input consumed __remains consumed__. If this behaviour is not desirable,
consider pairing `lookAhead` with `atomic`.

&gt;&gt;&gt; parse (lookAhead (string &quot;aaa&quot;) *&gt; string &quot;aaa&quot;) &quot;aaa&quot;
Success &quot;aaa&quot;
&gt;&gt;&gt; parse (lookAhead (string &quot;abc&quot;) &lt;|&gt; string &quot;abd&quot; &quot;abd&quot;
Failure .. -- lookAhead does not roll back input consumed on failure

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-139"></span><span id="local-6989586621679049994"><span class="annot"><a href="Text.Gigaparsec.html#lookAhead"><span class="hs-identifier hs-type">lookAhead</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679049994"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parser, @p@, to execute</span></span><span>
</span><span id="line-140"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679049994"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ and never consumes input if it succeeds.</span></span><span>
</span><span id="line-141"></span><span id="lookAhead"><span class="annot"><span class="annottext">lookAhead :: forall a. Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.html#lookAhead"><span class="hs-identifier hs-var hs-var">lookAhead</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec a
forall a. HasCallStack =&gt; a
</span><span class="hs-identifier hs-var">undefined</span></span><span> </span><span class="hs-comment">--TODO:</span><span>
</span><span id="line-142"></span><span>
</span><span id="line-143"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses its argument @p@, and succeeds when @p@ fails and vice-versa, never consuming
input.

If the parser @p@ succeeds, then @notFollowedBy p@ will fail, consuming no input.
Otherwise, should @p@ fail, then @notFollowedBy p@ will succeed, consuming no input
and returning @()@.

__Example:__ One use for this combinator is to allow for \&quot;longest-match\&quot; behaviour.
For instance, keywords are normally only considered keywords if they are not
part of some larger valid identifier (i.e. the keyword \&quot;if\&quot; should not parse
successfully given \&quot;ifp\&quot;). This can be accomplished as follows:

@
keyword :: String -&gt; Parsec ()
keyword kw = atomic $ string kw *&gt; notFollowedBy letterOrDigit
@

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-163"></span><span id="local-6989586621679049913"><span class="annot"><a href="Text.Gigaparsec.html#notFollowedBy"><span class="hs-identifier hs-type">notFollowedBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679049913"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ the parser, @p@, to execute, it must fail in order for this combinator to succeed.</span></span><span>
</span><span id="line-164"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser which fails when @p@ succeeds and succeeds otherwise, never consuming input.</span></span><span>
</span><span id="line-165"></span><span id="notFollowedBy"><span class="annot"><span class="annottext">notFollowedBy :: forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.html#notFollowedBy"><span class="hs-identifier hs-var hs-var">notFollowedBy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec ()
forall a. HasCallStack =&gt; a
</span><span class="hs-identifier hs-var">undefined</span></span><span> </span><span class="hs-comment">--TODO:</span><span>
</span><span id="line-166"></span><span>
</span><span id="line-167"></span><span class="annot"><span class="hs-comment">{-|
This parser produces @()@ without having any other effect.

When this parser is ran, no input is required, nor consumed, and the given value will always be
successfully returned. It has no other effect on the state of the parser.

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-175"></span><span id="local-6989586621679049915"><span class="annot"><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-type">unit</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679049915"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679049915"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-176"></span><span id="unit"><span class="annot"><span class="annottext">unit :: forall (f :: * -&gt; *). Applicative f =&gt; f ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var hs-var">unit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; f ()
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-177"></span><span>
</span><span id="line-178"></span><span class="hs-comment">-- TODO: infixl declaration</span><span>
</span><span id="line-179"></span><span id="local-6989586621679049919"><span id="local-6989586621679049920"><span id="local-6989586621679049921"><span class="annot"><a href="Text.Gigaparsec.html#%3C~%3E"><span class="hs-operator hs-type">(&lt;~&gt;)</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679049919"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679049919"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679049920"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679049919"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679049921"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679049919"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679049920"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679049921"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-180"></span><span id="%3C~%3E"><span class="annot"><span class="annottext">&lt;~&gt; :: forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f (a, b)
</span><a href="Text.Gigaparsec.html#%3C~%3E"><span class="hs-operator hs-var hs-var">(&lt;~&gt;)</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; b -&gt; (a, b)) -&gt; f a -&gt; f b -&gt; f (a, b)
forall a b c. (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span>
</span><span id="line-181"></span><span>
</span><span id="line-182"></span><span id="local-6989586621679049930"><span id="local-6989586621679049931"><span id="local-6989586621679049932"><span class="annot"><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator hs-type">($&gt;)</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679049930"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679049930"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679049931"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679049932"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679049930"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679049932"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-183"></span><span id="%24%3E"><span class="annot"><span class="annottext">$&gt; :: forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; b -&gt; f b
</span><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator hs-var hs-var">($&gt;)</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(b -&gt; f a -&gt; f b) -&gt; f a -&gt; b -&gt; f b
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; f a -&gt; f b
forall a b. a -&gt; f b -&gt; f a
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">(&lt;$)</span></span><span>
</span><span id="line-184"></span></pre></body></html>